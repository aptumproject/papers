| AIP | Title | Author | Type | Category | Status | Created |
|---|---|---|---|---|---|---|
| 11 | Sharding | Lucas Nestler | Standards | Network | In Progress | 22nd of July |

To successfully implement sharding, all tasks the participants in the network have, have to be splitted to dedicated groups of nodes. While this does create additional overhead, it also enables scalability, to increase the speed in addition to the security of the network with the number of nodes. This is the case, because of security reasons. To decrease the overhead of downloading data from the chain when synchronising with a different shard, memory-dependent cells have to be as constant as possible. On the other hand every cell has to be rotated as much as possible to ensure that nodes can not be bribed efficiently which would result in a consensus failure. With sufficiently randomised participants, the security is as strong as it is with full consensus. Therefore there is some kind of tradeoff as to how fast a network can rotate the participating nodes. One thing however is, that, while storing the state is expensive and needs to be acquired for full validation, there are many tasks that do not require the entire state to be stored and therefore can rotate more frequently. 

One such task is the gathering and grouping of transactions with valid signatures to blocks. It only requires processing power and a strong connection to the internet, so that blocks of transactions can be broadcasted to another node after a fixed time. If previously validated and fund change have been processed, smart contract execution does not require a lot of memory either. Instead, it requires real resources, such as RAM and processing power. Nodes performing those tasks therefore can be swapped easily without creating an overhead, which would only increase the security of the network.

However nodes that validate a transaction, to attest that the funds required to create a specific transaction exist as well as the transaction output exist, need to store a lot of data. Rotating these very frequemtly would force them to download the state of the new shard they have been assigned to, which creates an unwanted overhead, harming the network. Therefore nodes have to be assigned to shards for a longer period and then frequently be activated or deactivated randomly. This ensures that rotation still exists, making bribing difficult, but also drastically reduces the overhead. To further reduce the chance of bribing or randomly selecting a sample of validators which would favour an attacker, witnesses are randomly selected within a shard. Those witnesses allow the shard to reduce the chance of randomly assigning an attacker the whole power of the shard, which in turn increases the security for attacks with a low share of bribed nodes. However this does not increase the security against an attacker having 51% or more of the reputation in a shard, be it through bribing or a 51% attack. A countermeasure against that is increasing the minimum percentage of reputation that has to agree on a proposed block for it to be valid. This makes the consensensus more resistant against coordinated attacks while also having more casual downtimes as well as having a lower security against small uncoordinated attacks. Due to those issues, this modifcation is not applied and consensus across validators is achieved if 51% vote for a specific transaction.

Even more memory-intensive is storing the entire state, so that other nodes can download it. Memory-cells in the network act as the main medium of consensus, since those nodes add all changes of states from shards to the global state. More importantly, those nodes make cross-shard transactions possible. Additionally they allow anyone who synchronises with the network to download this state or parts of it, instead of having to traverse through the shards. It also allows nodes that have been assigned to different shards to download the required parts of the state without relying on users, like it is done in ethereum. This allows for higher speeds, better security and being sure that data can not simply be erased.

To summarise, the tasks in the network that can be performed are the following: 
- **Gathering**: Receiving data, checking it for syntax and grouping it into blocks.
- **Validating**: Confirming the monetary movement of a transaction and remove invalid data from a block what's invalid from a block. 
- **Witnessing**: Voting for blocks to ensure a minimum stake is behind it.
- **Execution**: Running a smart-contract (interactions) from a transaction.
- **Checkpointing**: Remebering the entire state, saving it and adding blocks to it

**Terminology**
- **Layer**: A group of nodes performing similar tasks.
- **Blocktime**: The size of the intervall between broadcasting data up a layer.
- **Period**: A period is the time it takes for data from arriving at a gathering node to their inclusion in a checkpoint. Due to the usage of four layers, it is equal to 4*Blocktime.

Due to the very different design compared to bitcoin and other large cryptocurrencies, the terms surrounding it have to be redefined. The commonly-known block time or block target, does not relate to the time it takes for the transaction to be included into the most recent state. Instead, it is defined as a constant delay after which the block currently held by a node is broadcasted to the next node in the chain of validation. All nodes in this chain that perform a similar task form a layer. In this case, the layers are made from gatherers, validators, executors and checkpointers. The time it takes, for a transaction that was received by a gatherer to be included in a state by a checkpointer is called period. A period is as long as the number of layers utilised times the block time. Therefore a transaction that does not involve a smart contract uses the first, second and fourth layer while skipping the third, setting its time till achieving finality to a constant three minutes. 

Splitting the tasks performed at exactly those points and not using a different approach is done to group every task by used resources. Additionally those tasks all display a fundamental function of a healthy blockchain-based ecosystem. Gathering and grouping data to broadcast it to the next layer allows for reduced latencies and optimised package-based data transmission, it also makes sure the basic transaction layout and syntax is correct, so that spam of useless data or even a DoS-attack does not reach any of the higher layers. Validating is required to ensure someone has the funds needed for a transaction, without it, anyone could spend any funds. Witnessing allows to increase the security of the validation layer, since the number of witnesses required to pass a block can be set to any arbitrary number. Without smart-contract execution, smart-contracts could not be used. Execution is bypassed if it is not needed. Checkpointing nodes are the most-trusted nodes of the network, which are allowed to summarise all data and act as reliable memory-cells.

Due to the high reliability requirement, checkpointing nodes are not changed frequently. There is an arbitrary number of nodes, for example 100, which are required to store the entire state. Those are the most-trusted nodes in the network with the highest cumulative weight, where the weight is calculated by taking votes, trustscore and stake in account. Out of those 100 nodes, the top 10 nodes will always be active checkpointing nodes, for as long as they have their spot in the top 10. The last 10 nodes are randomly selected out of the other 100 nodes. Those 20 nodes are then held accountable for storing all the data and updating it for the next block. If they do not store the data, they will not receive rewards and may get reduced trustscores due to bad (no) responses. Such a small number of nodes is used to ensure that only the most trustworthy are allowed to perform the most important task that requires the higher reliability. With a system like this, the top nodes will always be of high quality, making synchronisation quick and dependable. Any other number could be used, and it may be changed in future hard forks.

In contrast to checkpointing, a task that is strongly rewarded, some tasks can not be performed by certain participants. Some nodes may have weak RAM and can only perform gathering, while others have a lot of resources they want to lend out, making them execution nodes. That is why the rest of the nodes are not sampled randomly but instead every node can place a flag, what their prefered position is. A subgroup of the weight-based ranking is then used to determine who will receive a specific position. This allows nodes which have acquired more trust to be more often in the sample than rather new ones, while still giving them a chance to take their place in the consensus. 

Participating in the consensus requires some kind of reward, especially for work requiring a lot of energy, such as the execution of smart-contracts. That's why gatherers, validators and witnesses receive eigentrust score points for participating. In case AIP-04: Deflation is implemented, those nodes can also work their "negativity credits" off by being active, which reduces the amount their wallets gets decreased by every block. This means, when sufficiently active, no slashing at all will take place. For executors on the other hand, not just the previous activity-based bonus is active but they will also receive resource-credits (AIP-10a: Resource-based Feelessness) or fees for executing smart contracts (AIP-10b: Sidechain-based Feelessness). This system allows every party to be sufficiently rewarded while also giving them a chance to rise up to the top checkpointers to receive rewards.