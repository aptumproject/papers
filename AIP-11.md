| AIP | Title | Author | Type | Category | Status | Created |
|---|---|---|---|---|---|---|
| 11 | Sharding | Lucas Nestler | Standards | Network | In Progress | 22nd of July |

To successfully implement sharding, all tasks the participants in the network have, have to be split into dedicated groups of nodes. It creates additional overhead but enables scalability, increases the speed in addition to the security of the network with the number of nodes. 
Every cell has to be rotated as much as possible to ensure that attackers cant bribe nodes easily, which would result in a consensus failure. With sufficiently randomized participants, the security is as strong as it is with full consensus. Naturally, an overhead exists when every node is forced to redownload the entire state of another shard from the chain upon reassignment. That is why memory-dependent cells have to be as constant as possible.  Therefore there is some tradeoff as to how fast a network can rotate the participating nodes. 
Storing the entire state is expensive but is required to achieve full validation. Fortunately, not every node requires access to the entire state at all times. Those nodes can be rotated and swapped more frequently than others.

One such task is the gathering and grouping of transactions with valid signatures to blocks. It only requires processing power and a powerful connection to the internet, so that a gatherer can broadcast blocks of transactions to another node after a fixed time. If previously validated and fund change was processed, smart contract execution does not require much memory either. Instead, it requires real resources, such as RAM and processing power. Nodes performing those tasks, therefore, can be swapped easily without creating an overhead, which would only increase the security of the network.

However, nodes that validate a transaction, to attest that the funds required to create a specific transaction exist as well as the transaction output exist, need to store much data. Rotating these very frequently would force them to download the state of the new shard they have been assigned to, which creates an unwanted overhead, harming the network. Therefore nodes have to be assigned to shards for an extended period and then frequently be activated or deactivated randomly. This change ensures that rotation still exists, making bribing difficult, but also drastically reduces the overhead. To further reduce the chance of bribing or randomly selecting a sample of validators which would favor an attacker, witnesses are randomly selected within a shard. Those witnesses allow the shard to reduce the chance of randomly assigning an attacker the full power of the shard, which in turn increases the security for attacks with a low share of bribed nodes. However this does not increase the security against an attacker having 51% or more of the reputation in a shard, be it through bribing or a 51% attack. A countermeasure is increasing the minimum percentage of reputation that has to agree on a proposed block for it to be valid. This fix makes the consensus more resistant against coordinated attacks. Unfortunately, it induces more unexpected downtimes as well as having lower security against small uncoordinated attacks. Due to those issues, this modification is not applied, and consensus across validators is achieved if 51% vote for a specific transaction.

More memory-intensive is storing the entire state so that other nodes can download it. Memory-cells in the network act as the primary medium of consensus since those nodes add all changes of states from shards to the global state. More importantly, those nodes make cross-shard transactions possible. Additionally, they allow synchronizing participants to download this state or parts of it, instead of having to traverse through the shards. It also allows nodes that have been assigned to different shards to download the required parts of the state without relying on users, like it is done in ethereum. Having those nodes allows for higher speeds, better security, and knowing that data can not be erased.

To summarise, the tasks in the network that can be performed are the following: 
- **Gathering**: Receiving data, checking it for syntax and grouping it into blocks.
- **Validating**: Confirming the monetary movement of a transaction and remove invalid data from a block 
- **Witnessing**: Voting for blocks to ensure a minimum stake is behind it.
- **Execution**: Running a smart-contract (interactions) from a transaction.
- **Checkpointing**: Remembering the entire state, saving it and adding blocks to it

Due to the very different design compared to bitcoin and other significant cryptocurrencies, the terms surrounding it has to be redefined. The commonly-known block time or block target does not relate to the time it takes for the transaction to be included in the most recent state. It is defined as a constant delay after which the block currently held by a node is broadcasted to the next node in the validation chain. Nodes performing similar tasks form a layer, where each layer is accessed exactly once in the chain of validation. In this case, the layers are made from gatherers, validators, executors, and savers. The time it takes, for a transaction received by a gatherer to be included in a state by a saver is called period. A period is as long as the number of layers utilized times the block time. Therefore a transaction that does not involve a smart contract uses the first, second, and fourth layer while skipping the third. Its time till achieving finality is at a constant three minutes. 

Splitting the tasks performed at precisely those points and not using a different approach is done to group every task by used resources. Additionally, those tasks all display a fundamental function of a healthy blockchain-based ecosystem. Gathering and grouping data to broadcast it to the next layer allows for reduced latencies and optimized package-based data transmission. It also makes sure the basic transaction layout and syntax is correct. Spam of useless data or even denial-of-service attacks does not reach any of the higher layers. Validating is required to ensure someone has the funds needed for a transaction; without it, anyone could spend any funds. Witnessing allows increasing the security of the validation layer since the number of witnesses required to pass a block can be set to any arbitrary number. Without smart-contract execution, smart-contracts could not be used. Execution is bypassed if it is not needed. Checkpointing nodes are the most-trusted nodes of the network, which are allowed to summarise all data and act as reliable memory-cells.

Due to the high-reliability requirement, checkpointing nodes are not changed frequently. There is an arbitrary number of nodes, for example, 100, which are required to store the entire state. Those are the most-trusted nodes in the network with the highest cumulative weight, where the weight is calculated by taking votes, trust score, and stake in the account. Out of those 100 nodes, the top 10 nodes will always be active checkpointing nodes, for as long as they have their spot in the top 10. The last ten nodes are randomly selected out of the other 100 nodes. Those 20 nodes are then held accountable for storing all the data and updating it for the next block. If they do not store the data, they will not receive rewards and may get reduced trust scores due to inadequate responses. Such a small number of nodes is used to ensure that only the most trustworthy are allowed to perform the most critical task that requires higher reliability. With a system like this, the top nodes will always be of high quality, making synchronization quick and dependable. Any other number could be used, and it may be changed in future hard forks.

In contrast to checkpointing, a task that is strongly rewarded, some tasks can not be performed by specific participants. Some nodes may have weak RAM and can only perform gathering. Others have many resources they want to lend out, making them execution nodes. That is why the rest of the nodes are not sampled randomly, but instead, every node can place a flag, what their preferred position is. A subgroup of the weight-based ranking is then used to determine who will receive a specific position. This weight-based ranking allows nodes which have acquired more trust to be more often in the sample. It favors trusted nodes over new ones, while still giving them a chance to take their place in the consensus. 

Participating in the consensus requires some reward, especially for work requiring a lot of energy, such as the execution of smart-contracts. That is why gatherers, validators, and witnesses receive eigentrust score points for participating. In the case of AIP-04: Deflation, those nodes can also work their "negativity credits" off by being active, which reduces the amount their accounts get decreased by every block. This reduction of "negativity credits" means, when sufficiently active, no slashing at all will take place. Executors will not receive only the activity bonus, but they also receive resource-credits (AIP-10a: Resource-based Feelessness) or fees for executing smart contracts (AIP-10b: Sidechain-based Feelessness). This system allows every party to be sufficiently rewarded while also giving them a chance to rise to the top savers to receive rewards.
